pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "ahmedsalama3014/frontend-task" // Docker image name
        GIT_REPO = "git@github.com:Ahmed3019/my-cv-application.git" // GitHub repository URL
        K8S_NAMESPACE = "frontend-task" // Kubernetes namespace
        TERRAFORM_DIR = "/home/control/depi-study/final-project/terraform" // Directory for Terraform files
        INVENTORY_FILE = "hosts" // Define the inventory file path for Ansible
        EC2_PUBLIC_IP = '' // Initialize empty variable for EC2 IP
    }

    stages {
        stage('Clone GitHub Repo') {
            steps {
                script {
                    // Clone the GitHub repository
                    git branch: 'main', credentialsId: 'github-cred', url: "${GIT_REPO}"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    // Build the Docker image using the Dockerfile in the cloned repository
                    dockerImage = docker.build("${DOCKER_IMAGE}:latest")
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    // Push the built Docker image to Docker Hub
                    docker.withRegistry('https://index.docker.io/v1/', 'docker-hub-cred') {
                        dockerImage.push() // Push the image to the registry
                    }
                }
            }
        }

        stage('Run Terraform to create EC2') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    script {
                        sh 'terraform init'
                        sh 'terraform apply -auto-approve'
                        
                        // Extract the EC2 public IP from the Terraform output
                        EC2_PUBLIC_IP = sh(script: 'terraform output -json ec2_public_ip | jq -r .value', returnStdout: true).trim()
                        // Create an inventory file for Ansible using the EC2 IP
                        writeFile file: "${INVENTORY_FILE}", text: "[ec2]\n${EC2_PUBLIC_IP} ansible_user=ubuntu ansible_ssh_private_key_file=./nx-key.pem ansible_python_interpreter=/usr/bin/python3\n"
                    }
                }
            }
        }

        stage('Wait for EC2 to be Ready') {
            steps {
                script {
                    // Wait for a few seconds to ensure EC2 is up and ready
                    sleep 30
                }
            }
        }

        stage('Setup Environment on EC2') {
            steps {
                script {
                    // Ensure SSH key permissions are correct
                    sh 'chmod 600 ./nx-key.pem'

                    // Transfer the Ansible playbook and shell script to the EC2 instance
                    sh "scp -i ./nx-key.pem setup_environment.yml ubuntu@${EC2_PUBLIC_IP}:/home/ubuntu/"
                    sh "scp -i ./nx-key.pem run_playbook.sh ubuntu@${EC2_PUBLIC_IP}:/home/ubuntu/"

                    // Execute the shell script on the EC2 instance
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'bash /home/ubuntu/run_playbook.sh'"
                }
            }
        }

        stage('Wait After Setup') {
            steps {
                script {
                    // Sleep for 60 seconds after setup
                    sleep 60
                }
            }
        }

        stage('Create Kubernetes Namespace') {
            steps {
                script {
                    // Create the Kubernetes namespace, ensuring it doesn't exist already
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl create namespace ${K8S_NAMESPACE} || echo \"Namespace ${K8S_NAMESPACE} already exists\"'"
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    // Deploy the application to Kubernetes using deployment and service YAML files
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl apply -f deployment.yaml -n ${K8S_NAMESPACE}'"
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl apply -f services.yaml -n ${K8S_NAMESPACE}'"
                }
            }
        }
    }

    post {
        always {
            // Clean up the workspace after the build
            cleanWs()
        }
    }
}
