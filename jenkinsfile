pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "ahmedsalama3014/frontend-task" // Docker image name
        GIT_REPO = "https://github.com/Ahmed3019/my-cv-application.git" // GitHub repository URL
        K8S_NAMESPACE = "frontend-task" // Kubernetes namespace
        TERRAFORM_DIR = "terraform" // Directory for Terraform files
        INVENTORY_FILE = "inventory" // Ansible inventory file
        EC2_PUBLIC_IP = '' // Initialize empty variable for EC2 IP
        AWS_ACCESS_KEY_ID = credentials('aws-key-cred') // Access Key ID from Jenkins credentials
        AWS_SECRET_ACCESS_KEY = credentials('aws-secret-cred') // Secret Access Key from Jenkins credentials
    }

    stages {
        stage('Clone GitHub Repo') {
            steps {
                script {
                    git branch: 'main', credentialsId: 'github-cred', url: "${GIT_REPO}"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    dockerImage = docker.build("${DOCKER_IMAGE}:latest")
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    docker.withRegistry('https://index.docker.io/v1/', 'docker-hub-cred') {
                        dockerImage.push()
                    }
                }
            }
        }

        stage('Run Terraform to Create EC2') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    script {
                        sh '''
                            terraform init
                            terraform plan -out=tfplan \
                                -var="aws_access_key_id=${AWS_ACCESS_KEY_ID}" \
                                -var="aws_secret_access_key=${AWS_SECRET_ACCESS_KEY}"

                            # Check if there are changes to be applied
                            if terraform show -json tfplan | jq .resource_changes | grep -q '"change"'; then
                                echo "Changes detected, applying infrastructure changes..."
                                terraform apply -auto-approve tfplan
                            else
                                echo "No changes to infrastructure, skipping apply."
                            fi
                        '''
                    }
                }
            }
        }

        stage('Setup Environment on EC2') {
            steps {
                script {
                    // Ensure the nx-key.pem file has the correct permissions
                    sh 'chmod 600 ./nx-key.pem'

                    // Copy setup script to EC2
                    sh "scp -i ./nx-key.pem setup_environment.sh ubuntu@${EC2_PUBLIC_IP}:/home/ubuntu/"
                    sh "scp -i ./nx-key.pem setup_environment.yml ubuntu@${EC2_PUBLIC_IP}:/home/ubuntu/"

                    // Execute setup script on EC2
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'bash /home/ubuntu/setup_environment.sh'"
                }
            }
        }

        stage('Create Kubernetes Namespace') {
            steps {
                script {
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl create namespace ${K8S_NAMESPACE} || echo \"Namespace ${K8S_NAMESPACE} already exists\"'"
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl apply -f /home/ubuntu/k8s/deployment.yaml -n ${K8S_NAMESPACE}'"
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl apply -f /home/ubuntu/k8s/services.yaml -n ${K8S_NAMESPACE}'"
                }
            }
        }
    }
}
