pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "ahmedsalama3014/frontend-task"
        GIT_REPO = "https://github.com/Ahmed3019/my-cv-application.git"
        K8S_NAMESPACE = "frontend-task"
        TERRAFORM_DIR = "terraform"
        INVENTORY_FILE = "inventory"
        EC2_PUBLIC_IP = '' 
        AWS_ACCESS_KEY_ID = credentials('aws-key-cred') 
        AWS_SECRET_ACCESS_KEY = credentials('aws-secret-cred') 
    }

    stages {
        stage('Clone GitHub Repo') {
            steps {
                script {
                    git branch: 'main', credentialsId: 'github-cred', url: "${GIT_REPO}"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    dockerImage = docker.build("${DOCKER_IMAGE}:latest")
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    docker.withRegistry('https://index.docker.io/v1/', 'docker-hub-cred') {
                        dockerImage.push()
                    }
                }
            }
        }

        stage('Initialize Terraform') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    script {
                        // Initialize Terraform before planning/applying
                        sh """
                        terraform init -input=false \
                        -var="aws_access_key_id=${AWS_ACCESS_KEY_ID}" \
                        -var="aws_secret_access_key=${AWS_SECRET_ACCESS_KEY}"
                        """
                    }
                }
            }
        }

        stage('Check Terraform Changes') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    script {
                        // Run terraform plan to check for changes
                        def tfPlanOutput = sh(script: """
                            terraform plan \
                            -var="aws_access_key_id=${AWS_ACCESS_KEY_ID}" \
                            -var="aws_secret_access_key=${AWS_SECRET_ACCESS_KEY}" \
                            -no-color | tee plan.out
                        """, returnStatus: true)
                        
                        // Check if there are any changes
                        def planContainsChanges = sh(script: "grep 'No changes' plan.out", returnStatus: true)

                        if (planContainsChanges == 0) {
                            echo "No infrastructure changes detected. Skipping Terraform apply."
                            // If no changes are detected, fetch the existing instance IP
                            EC2_PUBLIC_IP = sh(script: 'terraform output -json instance_ip | jq -r .value', returnStdout: true).trim()
                            echo "Existing EC2 Public IP: ${EC2_PUBLIC_IP}"
                        } else {
                            echo "Changes detected. Applying Terraform."
                            // Run terraform apply if changes are detected
                            sh """
                            terraform apply -auto-approve \
                            -var="aws_access_key_id=${AWS_ACCESS_KEY_ID}" \
                            -var="aws_secret_access_key=${AWS_SECRET_ACCESS_KEY}"
                            """
                            // Fetch the EC2 public IP after creating the infrastructure
                            EC2_PUBLIC_IP = sh(script: 'terraform output -json instance_ip | jq -r .value', returnStdout: true).trim()
                            echo "New EC2 Public IP: ${EC2_PUBLIC_IP}"
                        }
                    }
                }
            }
        }

        stage('Install jq') {
            steps {
                script {
                    sh 'sudo apt-get update && sudo apt-get install -y jq'
                }
            }
        }

        stage('Wait for EC2 to be Ready') {
            steps {
                script {
                    sleep 60
                }
            }
        }

        stage('Setup Environment on EC2') {
            steps {
                script {
                    sh 'chmod 600 ./nx-key.pem'

                    sh "scp -i ./nx-key.pem setup_environment.sh ubuntu@${EC2_PUBLIC_IP}:/home/ubuntu/"
                    sh "scp -i ./nx-key.pem setup_environment.yml ubuntu@${EC2_PUBLIC_IP}:/home/ubuntu/"

                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'bash /home/ubuntu/setup_environment.sh'"
                }
            }
        }

        stage('Create Kubernetes Namespace') {
            steps {
                script {
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl create namespace ${K8S_NAMESPACE} || echo \"Namespace ${K8S_NAMESPACE} already exists\"'"
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl apply -f /home/ubuntu/k8s/deployment.yaml -n ${K8S_NAMESPACE}'"
                    sh "ssh -i ./nx-key.pem ubuntu@${EC2_PUBLIC_IP} 'kubectl apply -f /home/ubuntu/k8s/services.yaml -n ${K8S_NAMESPACE}'"
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}
